# HotelBooking
 
Анализ вычислительной сложности

На каждый запрос бронирования отеля программа выполняет:
- поиск отеля и создание нового (при его отсутствии)
  - отели хранятся в unordered_map, что в среднем O(1) на поиск и O(1) на вставку
- бронирование номера в соответствующем отеле
  - одна вставка в конец deque, хранящего историю бронирований - O(1)
  - увеличение счетчика броней клиента (брони клиента хранятся в unordered_map) - операция занимает O(1)
  - удаление устаревших броней, выходящих за пределы окна сбора статистики. Каждая бронь удаляется 1 раз и требует удаление из начала deque и один поиск (и, возможно, удаление) в unordered_map. - тоже O(1).
  - Возможность для оптимизации. unordered_map<clientId, число броинрований> в отеле нужен, чтобы обработать ситуацию, когда в течение суток один и тот же клиент совершает несколько запросов на бронирование. Если входные данные это исключают (но об этом нет явного указания в условиях задачи), то unordered map не нужен - количество различных клиентов, забронировавших в отеле в течение суток было бы равно количеству бронирований за этот период (размер deque).

На каждый запрос количества разных клиентов в отеле программа выполняет:
- поиск отеля в unordered_map - O(1)
- возврат константы, вычисленной во время бронирования - O(1)

На каждый запрос количества забронированных комнат в отеле программа выполняет:
- поиск отеля в unordered_map - O(1)
- возврат размера unordered_map - O(1)

Для Q запросов сложность будет O(Q). Максимальная длина названия отеля является константой L и ограничена 12 символами, поэтому можно считать, что она равна O(Q*L).

В BookingService.h обявлен макрос USE_UNORDERED_MAP_FOR_STORING_HOTELS. Если его закомментировать, то вместо unordered_map будет использоваться map, у которого сложность O(Log(Q * L)). Смысла в map большого нет, разве что если защититься от атаки на коллизии в хеш функции.


